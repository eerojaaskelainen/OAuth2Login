<?php namespace Accss;

use ProcessWire\InputfieldText;
use ProcessWire\WireInputData;

use function ProcessWire\__;


class InputfieldSecret extends InputfieldText 
{
	public bool $handleInline;
    /**
	 * Construct and establish default settings
	 * 
	 */
	public function __construct() {
		$this->handleInline = false;
		parent::__construct();
		$this->attr('type', 'password'); 
		$this->attr('size', 30); 
		$this->attr('maxlength', 256); 
		$this->attr('minlength', 6); 
		//$this->set('showPass', false); // allow password to be rendered in renderValue and/or re-populated in form?
		$this->set('unmask', false);
        $this->attr('autocomplete', 'new-password');
	}

    public static function getModuleInfo() {
		return array(
			'title' => __('Secret', __FILE__), // Module Title
			'summary' => __('Secret to store and retrieve from database. Uses TableSalt', __FILE__), // Module Summary
			'version' => 100,
		);
	}

	public function parseSecret(string $secret):string
	{
		/** @var FieldtypeSecret $ft */
		$ft = $this->modules->get('FieldtypeSecret');
		if (! $ft)
			throw new \ProcessWire\WireException('Could not get FieldtypeSecret module');
		return $ft::getEncryptedRawValue($secret);
		//$this->attr('value',$enc);
	}

	/**
	 * Retrieves secret from encrypted value. Note that this is used for static impelementations that includes IV
	 *  @param string $secret
	 *  
	 */
	public function retrieveSecret(string $secret):string
	{
		/** @var FieldtypeSecret $ft */
		$ft = $this->modules->get('FieldtypeSecret');
		if (! $ft)
			throw new \ProcessWire\WireException('Could not get FieldtypeSecret module');
		return $ft::decryptValueWithIV($secret);
	}
    /**
	 * Render Password input(s)
	 * 
	 * @return string
	 * 
	 */
	public function ___render() {
	
		$value = $this->attr('value'); 
		
        $trackChanges = $this->trackChanges();
        if($trackChanges) $this->setTrackChanges(false);

        if (! $this->getSetting('showPass'))
        {		           
            $this->attr('value', strlen($value) >0 ? '+++++++':'');
        }

        $attrStr = $this->getAttributesString();
		$out = "<input $attrStr />"; 
		
		
		$this->attr('value', $value);
		if($trackChanges) $this->setTrackChanges(true);
		
		return $out;
	}

    /**
	 * Render non-editable Inputfield
	 * 
	 * @return string
	 * 
	 */
	public function ___renderValue() {
		if(!$this->getSetting('showPass')) {
			$value = strlen($this->attr('value')) ? '******' : '';
		} else {
			$value = $this->wire()->sanitizer->entities($this->attr('value'));
		}
		$value = strlen($value) ? "<p>$value</p>" : "";
		return $value; 
	}

	public function ___processInput(WireInputData $input)
	{
		$previousValue = $this->attr('value');
		parent::___processInput($input);
		
		if (!$this->handleInline)
			return $this;

		$value = $this->attr('value');
		
		if (empty($value))
			return $this;
		elseif ($value == '+++++++')
		{
			$this->value= $previousValue;
			$this->resetTrackChanges();
			return $this;
		}

		$oldV = !empty($previousValue)? $this->retrieveSecret($previousValue) : '';
		if ($oldV !== $value);
			$this->value = $this->parseSecret($value);
		
		return $this;
	}
}
